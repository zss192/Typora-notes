# 绪论

## 知识点

1.操作系统(Operating System即OS)：指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口的环境。它是计算机系统中的最基本的系统软件。

2.操作系统的特征

- 并发性(最基本的特征)
  - 并发：交替发生(宏观同时发生微观交替发生)；并行：同时进行
- 共享性(最基本的特征)
  - 互斥共享：一个时间段内只允许一个进程访问
  - 同时访问：一个时间段内允许多个进程"同时"访问(微观上看仍是交替访问)
- 虚拟性：把一个物理上(实际存在)的实体变为若干个逻辑上(感觉存在)的对应物
  - 时分复用技术：利用处理机的空闲时间运行其他程序,提高处理机的利用率
  - 空分复用技术：利用存储器的空闲空间存放其他程序,提高内存的利用率
- 异步性：进程以不可预知的速度向前推进

3.操作系统的五大基本功能

> 由于功能描述较多，前四个的分类有印象即可(了解后可帮助理解)

- **处理器管理**：处理器的分配和运行是**以进程为单位**的，因此也是对进程的管理
  - 进程控制：负责进程的创建、撤销及状态转换
  - 进程同步：对并发执行的进程进行协调
  - 进程通信：负责完成进程间的信息交换
  - 进程调度：按一定算法进行处理器分配
- **存储器管理**：对内存进行分配、保护、和扩充
  - 内存分配：按一定的策略为每道程序分配内存
  - 内存保护：保证各程序互不干扰的运行
  - 内存扩充：为允许大型作业的运行，必须借助虚拟存储技术获得增加内存的效果
- **设备管理**：对计算机系统内的所有设备实施有效管理
  - 设备分配：按一定的分配原则对设备进行分配
  - 设备传输控制：实现物理的输入/输出操作
  - 设备独立性：用户程序中的设备与实际使用的物理设备无关
- **文件管理**：负责信息管理
  - 文件存储空间管理：负责存储空间的分配与回收
  - 目录管理：目录是为方便文件管理而设的数据结构能按名存取
  - 文件操作管理：实现文件操作，负责文件读写
  - 文件保护：提供文件保护功能
- **用户接口**：为方便用户使用操作系统而设
  - 命令接口：提供一组命令供用户控制自己的作业
    - 联机命令(交互式)：说一句做一句
    - 脱机命令(批处理)：说一堆一起做
  - 系统调用：用户向OS提出各种服务要求(如磁盘文件操作)
  - 图形接口：如Windows、安卓、IOS

4.操作系统的形成

> 各阶段的优点主要是解决了上一阶段的主要缺点

- 手工操作阶段：将纸带装入输入机，程序运行完成用户取走纸带
  - 缺点：用户独占全机、人机速度矛盾导致资源利用率极低
- 批处理阶段
  - 单道批处理系统：引入脱机输入/输出(通过中间设备减少CPU等待输入输出时间)技术，并监督程序(OS的雏形)负责控制作业的输入、输出
    - 优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升
    - 缺点：内存中仅有一道程序运行，CPU大量时间空闲等待I/O完成，资源利用率依然很低
    - 特点：自动性(作业依次自动运行)、顺序性、单道性
  - 多道批处理系统：每次可往内存中输入多道程序。（**操作系统正式诞生**）
    - 优点：多道程序并发执行，共享计算机资源，资源利用率大幅提升。
    - 缺点：用户响应时间长，没有人机交互功能(提交作业后只能等待完成，不能自主控制作业执行)
    - 特点：脱机使用PC、成批处理(分批次)、多道程序运行

5.操作系统的分类

- 批处理操作系统：包括单道批处理OS和多道批处理OS(详见上)
- 分时操作系统：以时间片为单位轮流为各个作业服务，各用户可通过终端与计算机交互
  - 优点：解决人机交互问题，允许多用户同时使用一台计算机，且操作相互独立。
  - 缺点：不能优先处理一些紧急任务，OS对各个作业完全公平，不区分任务紧急性。
  - 特点：多路性(多用户)、交互性、独占性(好像自己独占)、及时性
- 实时操作系统：对外部输入能在**规定时间内**(注意这里的实时不是马上而是规定时间(s/ms/us级))处理完毕并做出反应
  - 硬实时系统：必须在规定时间内完成(如导弹控制系统)
  - 软实时系统：能接受偶尔违反时间规定(如12306订票系统)
  - 特点：及时性、可靠性
- 其他操作系统
  - 嵌入式OS：运行在嵌入式系统环境中，如各种电器
  - 网络OS：把网络中各计算机互联=连起来，实现资源共享、信息交换
  - 分布式OS：各计算机地位相同(自治性)，工作由它们并行、协同完成且对用户透明

6.两种指令、处理器状态、程序

- 特权指令：不允许用户直接使用的指令，如I/O指令、中断屏蔽指令、清内存指令
- 非特权指令：普通的运算指令

- 核心态(管态)：能执行一切指令，能访问所有寄存器和存储器
- 用户态(目态)：只执行非特权指令，访问指定的寄存器和存储器
- 内核程序：系统的管理者，可执行一切指令、运行在核心态
- 应用程序：普通用户程序只能执行非特权指令，运行在用户态

> 助记：类似于Linux系统下的root用户和一般用户

7.操作系统的内核：操作系统最基本最核心的部分

- 时钟管理：实现计时功能
- 中断处理：负责实现中断机制
- 原语：一种特殊的程序
  - 处于操作系统最底层，最接近硬件
  - 运行具有原子性，**只能一气呵成，不能中断**
  - 运行时间短、调用频繁
- 系统资源的管理：进程管理、存储器管理、设备管理

8.中断：为实现多道程序并发执行而引入的一种技术(因I/O请求暂停执行时，可转去运行其它程序)，是CPU**从用户态进入核心态的唯一途径**

- 内中断：也称异常，由错误引起，信号来自内部
- 外中断：系统正常操作，如外设请求，信号来自外部

9.系统调用：系统给程序员(应用程序)提供的唯一接口，可获得OS的服务。在用户态发生，核心态处理

程序接口：由一组系统调用组成，进一步封装。

> 如今的应用程序通过**高级语言提供**的库函数间接进行系统调用，在用户态运行。

10.用户执行系统调用的过程：先传递系统调用所需参数，通过陷入(trap)指令进入核心态，然后执行相应服务程序，最后返回用户态。

11.操作系统的体系结构

- 大内核：将OS的主要功能模块作为系统内核

  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护

- 微内核：只保存基本的功能在内核

  - 优点：结构清晰，便于维护，可靠性高
  - 缺点：需频繁在核心态和用户态切换，性能低

  > 助记：管理层越多自然性能越高，但会导致分工不明确即结构混乱

## 习题

1.操作系统提供给编程人员的接口是（C）

A.库函数	B.高级语言	C.系统调用	D.子程序

答：程序员通过调用操作系统提供的**系统调用函数**来使用操作系统提供的服务。

而库函数是由**程序设计语言提供**的，它不是操作系统提供的接口。

2.在单处理机系统中，可并行的是（ D ）。

Ⅰ  进程与进程   Ⅱ  处理机与设备  Ⅲ  处理机与通道  Ⅳ  设备与设备

A.Ⅰ、Ⅱ和Ⅲ	B.Ⅰ、Ⅱ和Ⅳ

C.Ⅰ、Ⅲ和Ⅳ	D.Ⅱ、Ⅲ和Ⅳ

答：注意是并行即同时运行，而又是单处理机即单核，则同一时刻只能运行一个进程，但多个进程可以并发即交替的运行。

处理器、通道、设备都能并行运行，比如同时打印(设备)、计算(处理器)、传输数据(通道)

3.一个多道批处理系统中仅有  P1  和  P2  两个作业，  P2  比  P1  晚  5ms  到达，它们的计算和  I/O  操作顺序如下：

P1  ：计算  60ms  ，  I/O 80ms  ，计算  20ms

P2  ：计算  120ms  ，  I/O 40ms  ，计算  40ms

若不考虑调度和切换时间，则完成两个作业需要的时间最少是（B）

A.240ms	B.260ms	C.340ms	D.360ms

答：由于P2晚到，所以P1先执行

![image-20201210172938859](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201210172938859.png)

> 特别注意的是多道只是并发即交替执行，同一时刻CPU还是只能处理一个计算过程，但可以同时计算机处理I/O操作

4.下列选项中，不可能在用户态发生的事件是（C）

A.系统调用	B.外部中断	C.进程切换	D.缺页

答：系统调用本来就是操作系统提供给用户使用的接口，所以自然是由用户使用

外部中断比如用户敲击键盘，会产生外部中断，也是在用户态发生的

缺页会产生缺页中断，也是会发生在用户态下

而进程切换比如挂起一个正在运行的进程，显然用户是没有这个权限的，实质上需要修改程序状态字，且全程在核心态执行

# 进程管理

## 知识点

1.进程是进程实体的运行过程，是**资源分配的基本单位**，也是接受调度的基本单位

2.进程的基本特征

- 动态性(最基本特征)：进程是程序的一次执行过程，是动态的产生、变化和消亡的
- 并发性：内存中有多个进程，各进程可并发执行
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- 异步性：各进程以各自独立的、不可预知的速度向前推进(执行结果的不确定性)
- 结构性：每个进程都会配置一个PCB,结构上看进程由程序段、数据段、PCB组成

3.进程和程序的区别

- 程序是静态的，就是放在磁盘里的可执行文件，是一系列指令的集合
- 进程是动态的，是程序的一次执行过程，一个程序可产生多个不同的进程

4.进程的组成(严谨的说是进程实体或进程映像的组成)

- 进程控制块PCB：**是进程存在的唯一标志**，进程被创建时OS会为其创建PCB,进程结束后回收PCB
- 程序段：程序的代码
- 数据段：原始数据或运行过程产生的中间或结果数据

> PCB是给操作系统用的，程序段和数据段是给进程自己用的

5.进程控制块PCB(Process Control Block)的组成

![image-20201214225227721](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214225227721.png)

6.进程的组织方式

![image-20201214225941662](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214225941662.png)

7.进程的5种基本状态

- 创建态：此时进程正在被创建，OS会为进程分配资源、初始化PCB
- 就绪态：已经**获得除处理器外的所有资源**，一旦获得处理器可立即执行
- 运行态：此时进程已获得必要的资源并正在CPU上运行
- 阻塞态：由于某事件(如等待I/O完成)无法继续执行，此时即使把处理器分给它也无法运行
- 终止态：此时进程正在消失，OS会回收其内存资源并回收PCB

8.进程控制：实现进程状态的相互转换，用原语实现

![image-20201214231822060](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214231822060.png)

> 助记：一次只能获取一个所需资源

9.进程的创建

![image-20201214233255993](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233255993.png)

进程的终止

![image-20201214233328937](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233328937.png)

进程的阻塞和唤醒

![image-20201214233425078](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233425078.png)

进程的切换

![image-20201214233516560](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233516560.png)

> 无论哪个进程控制原语，其实只做三件事
>
> 1.更新PCB中的信息（修改进程状态）
> 2.将PCB插入合适的队列
> 3.分配/回收资源

10.进程通信：即进程间的信息交换。进程的互斥和同步交换信息少且效率低称为低级进程通信方式。PV原语称为低级进程通信原语。

11.高级进程通信可分为三类

- 共享存储：划出一块共享存储区，多个进程互斥的对其进行读写来实现通信
- 信息传递：进程间以消息为单位，通过OS提供的发送/接受消息原语进行数据交换
  - 直接通信方式：消息直接挂到接受进程的消息缓冲队列上
  - 间接通信方式：消息先发到中间实体(信箱)中，也称为信箱通信方式。(eg：计网的电子邮件系统)
- 管道：用于连接读写进程的一个共享文件，其实就是一个缓冲区
  - 一个管道只能实现半双工，双向通信需两个管道
  - 写满不能再写，读空不能再读。没写满不能读，没读空，不能写。

12.引入线程带来的变化

![image-20201215002014259](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215002014259.png)

13.线程的属性

- 处理机调度的单位（引入线程前是进程）
- 也有就绪、阻塞、运行三种基本状态
- 几乎不拥有系统资源，切换同进程的线程系统开销较小
- 进程间的多个线程也可并发执行，提高了系统的吞吐量
- 由于共享内存地址空间，同一进程的线程通信甚至无需OS干预
- 本身不能单独运行，只能包含在进程中并在进程中执行

14.线程的实现方式

- 用户级线程：通过线程库实现，由应用程序负责线程管理，用户看有多线程而OS意识不到线程的存在
  - 优点：线程切换无需进入核心态，开销小效率高
  - 缺点：当一个线程被阻塞时，整个进程都会阻塞，多个线程不可并行运行
- 内核级线程：由OS内核管理，OS为每个线程建立相应的TCB，**是处理机分配的单位**
  - 优点：一个线程阻塞后其它线程仍可执行，多线程可并行执行
  - 缺点：线程切换要在核心态完成，管理成本高，开销大

> 很多编程语言提供了线程库(用户级)，而大多数操作系统都实现了内核级线程(内核级)

15.多线程模型：根据用户级线程和内核级线程的映射关系，可分为以下三种

- 一对一模型：一个用户级线程映射到一个内核级线程
  - 优点：一个线程阻塞不影响其它线程，各个线程可并行执行，并发度高
  - 缺点：线程管理都需要操作系统支持，开销大
- 多对一模型：多个用户级线程映射到一个内核级线程
  - 优点：在用户空间管理，开销小效率高
  - 缺点：一个线程阻塞会导致整个进程阻塞，多个用户级线程不能并行执行
- 多对多模型：m个用户级线程映射到n个内核级线程(m≥n)
  - 优点：多个用户级线程可并行执行，不会限制用户级线程数量，一个用户级线程阻塞不影响其它线程

16.七状态模型

![image-20201215002014269](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487486948-692d915e-a888-4ee5-bd98-6b40503de95c.png)

> 注意挂起和阻塞都没获得CPU服务，但挂起是将进程映像调到外存，而阻塞仍在内存

17.处理机调度：按某种算法选择一个进程将处理机分配给它

- 高级调度(作业调度)：从**后备**队列中选择合适的**作业**将其调入**内存**，并为其创建进程
- 中级调度(内存调度)：从**挂起**队列中选择合适的**进程**将其数据调回**内存**
- 低级调度(进程调度)：从**就绪**队列中选择一个**进程**为其分配**处理机**

> 助记：从高到低的调度其实也是从外到内的过程，先是作业调度创建进程然后是进程调度执行进程。而发生频率由低到高

18.引起进程调度或进程切换的原因

- 进程主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞(如等待I/O)
- 进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理(如I/O中断)
  - 有更高优先级的进程进入就绪队列

19.不能进行进程调度和进程切换的情况

- 处理中断的过程中
- 在操作系统内核程序临界区(互斥访问的一段程序)中
- 原子操作中(不可中断要一气呵成)

20.进程调度的方式

- 非抢占方式(不可剥夺式)：只允许进程主动放弃(完成或主动进入阻塞态)处理机，即使有更紧迫的任务到达也不搭理它
  - 实现简单，开销小但无法及时处理紧急任务，适用于早期批处理系统

- 抢占方式(可剥夺方式)：有个更重要的进程需使用处理机，则立即暂停当前进程，将处理机分配给它
  - 可优先处理更紧急的任务，也可让进程按时间片轮流执行，适用于分时、实时操作系统

21.进程的切换与过程

- 先对原来运行进程各种数据的保存
- 然后对新的进程各种数据的恢复

> 进程调度和切换都是有代价的，过于频繁会使系统效率下降

22.调度算法的评价指标

- CPU利用率：CPU忙碌的时间占总时间的比例	（忙碌时间/总时间）
- 系统吞吐量：单位时间内完成作业的数量      （完成作业数量/花了多少时间）
- 周转时间：作业从提交到完成的时间间隔      （作业完成时间-提交时间）
  - 用户更关心自己单个作业的周转时间
- 平均周转时间：多个作业周转时间的平均值    （各作业周转时间之和/作业数）
  - 操作系统更关系系统的整体表现即所有作业的周转情况
- 带权周转时间：作业周转时间与运行时间之比   （周转时间/运行时间）
  - 若周转时间相同，实际运行时间越长用户越满意(等的时间相对少)
- 平均带权周转时间：多个作业的带权周转时间的平均值 （各作业周转时间之和/作业数）

23.周转时间包括四部分

- 作业在外存后备队列等待调度的时间(高级调度)
- 进程在就绪队列等待进程调度的时间(低级调度)
- 进程在CPU上执行的时间
- 进程等待I/O操作完成的时间

> 由此可看出周转时间含很多等待时间，显然运行时间越长即等待时间越短用户越满意

24.早期批处理的调度算法

- 先来先服务算法(FCFS---->First Come First Serve)

![image-20201215002014271](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487741194-4a1e43a6-4819-4372-9bcd-0ab8e1d299a9.png)

- 短作业优先算法(SJF---->Shortest Job First)

![image-20201215111142387](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111142387.png)

- 高响应比优先算法(HRRN---->Hightest Response Ratio Next)

![image-20201215111412289](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111412289.png)

三种调度算法对比

![image-20201215112543300](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112543300.png)

25.交互式系统的调度算法

- 时间片轮转算法(RR---->Round-Robin)

![image-20201215112543302](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487858888-881de75c-ebec-430f-8e64-6275d82d1b56.png)

- 优先级调度算法

![image-20201215120938537](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215120938537.png)

- 多级反馈队列调度算法

![image-20201215121333296](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215121333296.png)

三种调度算法对比

![image-20201215121427700](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215121427700.png)

26.各调度算法优点

| 算法             | 优点                                              |
| ---------------- | ------------------------------------------------- |
| FCFS             | 公平                                              |
| SJF              | 能尽快处理完短作业，平均等待/周转时间等参数很优秀 |
| 时间片轮转调度   | 可让各个进程得到及时的响应                        |
| 优先级调度       | 可灵活的调整各进程被服务的机会                    |
| 多级反馈队列调度 | 对以上算法折中权衡，综合表现优秀平衡              |

27.同步和互斥

































## 习题

1.进程处于临界区不能进行处理机调度（X）

答：对于内核程序临界区访问的资源如果不尽快释放，极有可能影响OS内核的其它管理工作，所以处于内核程序临界区的时候不能进行调度和切换。

而题目所说的是临界区，这包括普通的临界区如打印机，此时调度和切换并不会影响OS内核的管理工作。而且如果访问打印机这种慢速外设如果不能调度系统性能肯定非常低。

2.适用于早期批处理调度算法的计算

- 先来先服务算法

![image-20201215002014276](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487747580-88c0b185-41ef-40a2-83cf-0183ec7dc383.png)

- 非抢占式的短作业优先调度算法(SPF)

![image-20201215111716009](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111716009.png)

- 抢占式的短作业优先调度算法(SRTN)

![image-20201215112027037](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112027037.png)

- 高响应比优先算法

![image-20201215112211464](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112211464.png)

3.适用于交互式系统的算法的计算

- 时间片轮转算法中时间片为2时

![image-20201215112211466](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487869975-cee512a6-a13e-4f77-8457-a0bf1ee1a0dc.png)

注：以下括号内表示当前处于就绪队列的进程，下同

0时刻(P1(5))：0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片

2时刻(P2(4) > P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。(注意: 2时刻， P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，**默认新到达的进程先进入就绪队列**)

4时刻(P1(3)→ P3(1) > P2(2))：4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾

5时刻(P3(1) > P2(2) > P4(6))：5时刻，P4到达插到就绪队尾（注意：**由于P1的时间片还没用完，因此暂时不调度**。另外，**此时P1处于运行态，并不在就绪队列中**）

6时刻(P3(1)→ P2(2) > P4(6)→P1(1))：6时刻，P1时间片用完，下 处理机，重新放回就绪队尾，发生调度

7时刻(P2(2) →P4(6)→P1(1))：虽然**P3的时间片没用完**，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。

9时刻(P4(6) > P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机

11时刻(P1(1)→ P4(4) )：P4时间片用完，重新回到就绪队列。P1 上处理机

12时刻(P4(4) )：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机

14时刻()：就绪队列为空，因此让P4接着运行一个时间片。

16时刻：所有进程运行结束

- 时间片轮转算法中时间片为5时

![image-20201215122143265](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215122143265.png)

0时刻(P1(5) )：只有P1到达，P1. 上处理机。

2时刻(P2(4))：P2到达，但P1时间片尚未结束，因此暂不调度

4时刻(P2(4)> P3(1))：P3到达，但P1时间片尚未结束，因此暂不调度

5时刻( P2(4)> P3(1)> P4(6) )：P4到达，同时，P1运行结束。发生调度，P2. 上处理机。

9时刻( P3(1)> P4(6) )：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。

10时刻( P4(6) )：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。

15时刻( )：P4时 间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。

16时刻( )：P4运行完，主动放弃处理机。所有进程运行完。

如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此**时间片不能太大**。

另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果**时间片太小，会导致进程切换过于频繁**，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见**时间片也不能太小。**

- 非抢占式优先级调度算法

![image-20201215122143277](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487927217-c4f02d78-a485-402e-8906-7210924af5ef.png)

0时刻(P1)：只有P1到达，P1上处理机。

7时刻(P2、P3、P4)：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。

8时刻(P2、P4)：P3完成，P2、 P4优先级相同，由于P2先到达，因此P2优先上处理机

12时刻(P4)：P2完成，就绪队列只剩P4，P4上处理机。

16时刻()：P4完成，所有进程都结束

- 抢占式优先级调度算法

![image-20201215122522783](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215122522783.png)

0时刻(P1)：只有P1到达， P1上处理机。

2时刻(P2)：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。

4时刻(P1、P3)：P3到达， 优先级比P2更高，P2回到就绪队列，P3抢占处理机。

5时刻(P1、P2、P4)：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机

7时刻(P1、P4)：P2完成,就绪队列只剩P1、P4，P4上处理

11时刻(P1)：P4完成，P1上处理机

16时刻()：P1完成，所有进程均完成

- 多级反馈队列调度算法

![image-20201215122522799](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593488009525-1e4f8020-a00a-44d3-8ebe-30d4df840daf.gif)








































































