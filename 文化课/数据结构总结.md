# 各类型存储结构

![image-20200531145418964](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200531145418964.png)

## 顺序表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png" alt="image-20200529171311253" style="zoom: 50%;" />

```c
#define MAXSIZE 100	//顺序表可能达到的最大长度
typedef struct
{
    ElemType *elem;	//存储空间的基地址(例如用L.elem[0]取元素)
    int length;	//当前长度
}SqList;
```

L.elem[i]取值 	//L.length-1=>i>=0，如元素为1,2,3，L.length=3，i=0,1,2

## 单链表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png" alt="image-20200529170658268" style="zoom: 67%;" />

```c
typedef struct LNode
{
    ElemType data;	//结点的数据域
    struct LNode *next;	//结点的指针域，指向下一结点
}LNode,*LinkList;	//LinkList为指向结构体LNode的指针类型(相当于LNode *)
```

若带头结点，空表条件为L->next==NULL（L为头指针指向头结点永不为空）

若不带头结点，空表条件为L==NULL

## 双向链表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png" alt="image-20200529170625502" style="zoom: 67%;" />

```c
typedef struct DuLNode
{
    ElemType data;	//结点的数据域
    struct DuLNode *prior;	//指向直接前驱
    struct DuLNode *next;	//指向直接后继
}DuLNode,*DuLinkList;	
```

## 顺序栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png" alt="image-20200529172642776" style="zoom: 50%;" />

```c
#define MAXSIZE 100	//顺序栈存储空间的初始分配量
typedef struct
{
    SElemType *base;	//栈底指针
    SElemType *top;		//栈顶指针
    int stacksize;		//栈可用的最大容量
}SqStack;
```

栈空：S.top==S.base	//首尾指针相同

栈满：S.top-S.base==S.stacksize	//尾-首等于最大容量即为满

## 链栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png" alt="image-20200529171934385" style="zoom: 50%;" />

```c
//定义类似，类似操作受限的单链表
typedef struct StackNode
{
    ElemType data;	//数据域
    struct StackNode *next;	//指向下一结点
}StackNode,*LinkStack;
```

链栈一定是没有头结点，所以栈空的条件为：S==NULL

## 循环队列

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png" alt="image-20200529171646363" style="zoom: 50%;" />

```c
#define MAXSIZE 100 //队列可能达到的最大长度
typedef struct
{
    QElemType *base;	//存储空间的基地址
    int front;	//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）
    int rear;	//尾指针
}SqQueue;
```

队空：Q.front==Q.rear	//首尾指针相同

//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1

队满：(Q.rear+1)%MAXSIZE==Q.front	

## 链队

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png" alt="image-20200529172331805" style="zoom: 67%;" />

```c
//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针
typedef struct QNode
{
    QElemType data;	//数据域
    struct QNode *next;	//指向下一结点
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;	//队头指针(相等于QNode *front)
    QueuePtr rear;	//队尾指针
}LinkQueue;
```

队空：Q.front=Q.rear

由于串、数组、广义表的存储结构不是重点在这里就不再列出其存储结构

## 小结

有==头尾指针==的有：==顺序栈和队列==(顺序和链式)

- 顺序栈（栈顶和栈底）
- 循环队列
- 链队

## 顺序二叉树(不常用)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-100.png" alt="image-100" style="zoom:67%;" />

```c
#define MAXSIZE 100	//二叉树的最大结点数
typedef TElemType SqBiTree[MAXSIZE]	//0号存储根结点
SqBiTree bt;
```

## 二叉链表(常用)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-102.png" alt="image-102" style="zoom:67%;" />

```c
typedef struct BiTNode
{
	TElemType data;	//结点数据域
    struct BiTNode *lchild,*rchild;	//左右孩子指针
}BiTNode,*BiTree;
```

## 线索二叉树

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-103.png" alt="image-103" style="zoom:67%;" />

```c
typedef struct BiThrNode
{
    TElemType data;
    struct BiThrNode *lchild,*rchild;	//左右孩子指针
    int LTag,RTag;	//左右标志
}BiThrNode,*BiThrTree;
```

## 孩子兄弟二叉树

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-104.png" alt="image-104" style="zoom:67%;" />

```c
tyrpedef struct CSNode	//又称二叉链表表示，本质存的是树用类似存二叉树的方法存
{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;	//即左是孩子右是兄弟
}CSNode,*CSTree;
```

## 邻接矩阵

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606155925297.png" alt="image-20200606155925297" style="zoom:50%;" />

```c
#define MaxInt 32767   //表示极大值，即∞
#define MVNum 100       //最大顶点数 
typedef char VertexType;   //假设顶点的数据类型为字符型 
typedef int ArcType;       //假设边的权值类型为整型 
typedef struct{ 
  VertexType vexs[MVNum];       //顶点表 
  ArcType arcs[MVNum][MVNum];   //邻接矩阵 
  int vexnum,arcnum; //图的顶点数和边数 
}AMGraph; 
```

## 邻接表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606160127426.png" alt="image-20200606160127426" style="zoom:50%;" />

```c
//注意存的是顶点数组下标不是存的顶点本身
typedef  struct  ArcNode {   //边结构
      int  adjvex;                              //该边所指向的顶点位置
      struct  ArcNode *nextarc;   //指向下一条边的指针
      OtherInfo    info;                     //和边相关的信息
} ArcNode；
#define MVNum 100
typedef   struct  VNode{ //顶点结构
     VertexType   data;              //顶点信息
     ArcNode   * firstarc;         //指向依附该顶点的第一条弧的指针
} VNode, AdjList[MVNum];  
typedef   struct {                 //图结构
      AdjList   vertics ;           //邻接表
      int  vexnum, arcnum;  //顶点数和弧数
      int  kind;                       //图的种类
}  ALGraph;  
```



# 1.绪论

## 知识点

1.逻辑结构：数据之间的相互关系。

- 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。
- 线性结构 数据元素之间一对一的关系
- 树形结构 数据元素之间一对多的关系
- 图状结构或网状结构 结构中的数据元素之间存在多对多的关系

也可分为线性结构(可理解成一条直线能串起来)和非线性结构

2.存储结构分为顺序存储结构和链式存储结构

3.算法**五个特性**： 有穷性、确定性、可行性、输入、输出

4.算法设计要求：正确性、可读性、健壮性、高效性。(好的算法)

5.typedef可以理解成给现有数据类型起个别名

例如：typedef struct{.....}SqList，即给struct{......}起了个名字叫SqList

也用于类似于typedef int ElemType; 给int 起个别名叫ElemType即ElemType a;等价于int a;

这样做的好处是代码中用ElemType定义变量，如果想修改变量类型只需修改typedef ** ElemType即可，而不用一一修改。

> 我们注意到有时候会有typedef struct LNode{...}LNode，即struct后有个LNode,这是因为如果结构体内部有指向结构体的指针则必须在struct后面加上LNode(单链表里有next指针struct LNode *next)

6.时间复杂度：可以理解成就看执行了多少次

7.研究数据结构就是研究数据的逻辑结构、存储结构及其基本操作

8.抽象数据类型的三个组成部分为数据对象、数据关系、基本操作。



# 2.线性表

## 知识点

1.线性表和有序表合并的时间复杂度

线性表的合并时间复杂度为O(m*n)

A=(7,5,3,11)，B=(2,6,3)，结果为A=(7,5,3,11,2,6)

算法需要循环遍历B(O(n))且LocateElem(A)(判断是否与B重复为O(m))所以为O(m*n)

有序表的合并时间复杂度为O(m+n)

A=(3,5,8,11)，B=(2,6,8)，结果为A=(2,3,5,6,8,11)

算法只需同时遍历A和B，然后将还没遍历完的那个直接插到最后就行，所以是相加

2.顺序表插入平均移动n+1/2，删除平均移动n-1/2

# 4.串、数组和广义表

## 数组

### 求next数组和nextval数组

![image-20200530144018875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png)

当j=1(即第一个字符)时为特殊情况next和nextval均为0

### next数组：其值为当前字母前方的最大前后缀+1

例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1

j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2

j=5(A)，前面有ABAB，前后缀为AB，2+1=3	//ABA和BAB不等，所以AB为最大前后缀

### nextval数组：两种情况

J对应的字母与next[j]的值转换为j对应的字母==不等==时，nextval值为next[j]

J对应的字母与next[j]的值转换为j对应的字母==相等==时，nextval值为nextval[next[j]]

> 由此可看出要想求nextval，必须正确的求出next

例如：j=2，j对应的字母为B，next[j]即next[2]=1，也就是j=1对应的字母为A，B与A不等则nextval值为next[2]=1

j=3，j对应的字母为A，next[j]即next[3]=1，也就是j=1对应的字母为A，A与A相等则nextval值为nextval[next[j]]=nextval[1]=0

### 行优先和列优先

![image-20200530152310875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530152310875.png)

其实就是行优先就是先一行一行的存，列优先就是一列一列的存

无论是哪个其元素位置如a\[2][3]位置不变，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它

## 广义表

广义表是线性表的推广(非线性)，也称列表（暂时理解成python里的列表）

广义表元素可为原子或子表

广义表长度：即元素个数(最外层括号里的小括号算一个元素)

广义表深度：就看有多少对括号就行(注意要将里面的子表全部展开)

表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾

> 注意表头是第一个元素不带最外层的那个括号，表尾带最外层的括号

例如A=((a,b),c)，表头为(a,b)而表尾为(c)

## 串

串的子串个数为n(n+1)/2+1（空串也算所以加1）

## 习题

![image-20200530201544055](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530201544055.png)

# 5.树和二叉树

## 知识点

1.满二叉树(最完美最满的状态)   完全二叉树(编号是连续的即最右面缺而且是最后一层缺)

完全二叉树度为1的结点个数为0或1

当前结点编号为i，它的左孩子编号为2i，右孩子为2i+1（二叉树顺序存储就是按编号，不存在设为0）

![image-20200604171747502](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604171747502.png)

2.二叉树常用性质

- n~0~= n~2~+1 即叶子节点个数为度为2的结点个数加1
- 有 n 个结点的完全二叉树的深度为⎣log~2~ ^n^⎦+1 
- 深度为k的二叉树最多有2^k^-1个结点(满二叉树)

3.二叉树遍历

- 先序遍历NLR：根节点->左子树->右子树
- 中序遍历LNR：左子树->根节点->右子树。必须要有中序遍历才能画出相应二叉树
- 后续遍历LRN：左子树->右子树->根节点。
- 先后中遍历指的是根结点在先还是中还是右，且时间复杂度均为O(n)（自己便于记忆写的）
- 层次遍历：一层一层从上到下，从左到右

4.二叉树线索化目的是加快查找结点的前驱或后继的速度。实质上就是遍历一次二叉树，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点

5.哈夫曼树即带权路径最短树，也称最优树。

树的带权路径长度=树根到各==叶子==结点的路径(树根到该结点要走几步)乘对应权值；通常记作 WPL=∑wi×li

6.哈夫曼编码是最优前缀编码(任一个编码都不是其他编码的前缀，便于通信减少数据传输)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604205104233.png" alt="image-20200604205104233" style="zoom: 50%;" />

哈夫曼树没有度为1的结点，且不一定是完全二叉树

7.树的存储结构有三种:双亲表示法、孩子表示法、孩子兄弟表示法,其中孩子兄弟表示法是最常用的表示法,任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。

8.含有n个节点的二叉树共有(2n)!/(n!*(n+1)!)	(常考3个节点共5种)

9.二叉树的高度是最大层次数(根节点为第一层)

10.树和二叉树均可以为空(注意树可为空是在严蔚敏教材中可空，有的地方规定不能为空)

11.树的先序对应二叉树的先序，树的后序对应二叉树的中序(这里的二叉树一般指经孩子兄弟法转换的树)

12.哈弗曼树属于二叉树有左右子树之分

## 习题

**1.**

![image-20200604180443957](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604180443957.png)

答：n~0~= n~2~+1              ==n~1~=0或n~1~=1==        n~0~+n~1~+n~2~=1001

**2.**树的存储结构中，孩子兄弟表示法又称二叉链表表示法

![image-20200604181448145](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604181448145.png)

**3**.在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是______82_。

答：==任何树中，分支数(度数之和)比节点数少1==

题目中，分支数为20\*4+10\*3+1\*2+10\*1=122，所以有123个节点

度为0的节点为123-20-10-1-10=82

也可用公式n~0~=1*n~2~+2\*n~3~+3\*n~4~+1=1+2\*10+3\*20+1=82

**4.**设哈夫曼树中有199 个结点,则该哈夫曼树中有_100__个叶子结点

答：哈弗曼树没有度为1的点,n0=n2+1,n0+n2=199,所以n0=100

**5.**一棵高度为4的完全二叉树至少有______8_个结点

答：前三层是满二叉树，最后一层只有一个即1+2+4+1=8

**6.**

![image-20200605151226555](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151226555.png)

后是左右根，所以C是根，根据中序(左根右)得到DEBA均是C左子根

根据后序的DABE得到E是DABE的根，再由中序的DEBA得到D是E的左字根，BA是E的右子根

后序是左右根是AB，而中序是左根右是BA，正好相反则当没有左时正好是右根和根右，即B是根

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151625428.png" alt="image-20200605151625428" style="zoom:50%;" />

7.一颗高度为h的完全二叉树至少有_____2^h-1^__个结点

答：最少的情况就是前h-1层是满的，第h层只有一个。

即2^h-1^-1(前h-1层)+1(第h层)

8.有n个结点，高度为n的二叉树的数目为_____2^n-1^__

答：结点数和高度相同，那么每层都只有一个结点。对于除根节点以外的结点都可能是左子树或右子树，即有两种可能，n-1个2相乘即为2^n-1^

9.二叉树遍历

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607144152588.png" alt="image-20200607144152588" style="zoom: 50%;" />

注意中序先访问C的左而不是先访问W的左

10.二叉树与森林之间的转换（左孩子右兄弟）

![image-20200607160958011](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607160958011.png)

# 6.图

## 知识点

1.完全图：任意两个顶点都有边，都可达，有向完全图的边数(n*(n-1))是无向完全图的2倍

2.子图：一个图的一部分称为其子图

3.回路或环：简单来说就是转个圈

4.简单回路：转圈的过程不能有重复的点

5.连通图：图的每两个顶点都有一个到另一个的路径，若都互相可达就是强连通(不一定是完全图)

6.生成树：含图的全部顶点但只有n-1条边而且是连通图(就是一条线串起来所有顶点)

7.邻接矩阵存储图，若没权值1代表有边，0代表没有。若有权值，有边存权值，没边存无穷大

8.图中度数之和为边数之和个数的2倍(一条边被两个顶点共用所以是2倍)

9.完全图要求每两个顶点都有一条边(无向时)，连通图只要求两个顶点之间存在路径就行(可能是多条边)

10.深度优先(DFS)即越深越好,直到不能再深了这时退到上一层继续深度优先。类似先序借助于栈(递归)

若用邻接矩阵实现时间复杂度为O(n^2^)，邻接表是O(n+e)即O(顶点+边)

广度优先(BFS)就是越广越好类似层次遍历，而且先被访问的节点其子节点也先被访问。借助于队列(存放被访问的结点)

层次遍历就是一层一层从左到右遍历

树的先序，中序，后序遍历用栈，层次遍历用队列。

11.最小生成树：加权连通图的最小权值生成树，常用于修一条路使得可到所有顶点且花费最小

普里姆(Prim)算法：加点不构成回（选可达的最小的点）适合稠密图

克鲁斯卡尔(Kruskal)算法：加边不构成回（选现有的最小的边）适合稀疏图

12.v(vertex)是顶点，e(edge)是边

13.求某个点到其余各点的最短路径：迪杰斯特拉(Dijkstra)算法O(n^2^)（必考）

求每对顶点的最短路径：弗洛伊德(Floyd)算法O(n^3^)（不常考）

Floyd：比如求v0到其他顶点，在邻接矩阵中，v0这一行这一列这一主对角线划掉，剩下的中间经过v0看是否比原来路径短，若短则更新

14.拓扑排序：对有向无环图的顶点的一种排序

15.AOV网：在有向图中，用顶点表示活动，弧表示活动间的优先关系，则称此有向图为用顶点表示活动的网络（Activity On Vertex Network翻译即在顶点上的活动）

16.拓扑排序可以解决先决条件问题，比如学院有的课是其他课的基础，怎样排课的问题

找到入度为0的点输出，删除该点的所有出边，找到剩余点中入度为0的点输出，删除所有出边，重复操作(借用队列实现，若入度为0则入队，当前没有入度为0的点则出队，也可用栈二者结果不同)

17.AOE网：用顶点表示事件，弧表示活动(注意和AOV网相反)，弧上的权值表示活动持续时间(Activity On Edge Network)。其用于研究 1.完成工程最短时间      2.哪些活动是影响工程的关键

18.关键路径：即从源点(起始点)到汇点(最终点)最长的路径，路径上的活动称为关键活动

19.事件的最早发生时间：从前往后找前驱节点到当前节点的最大时间   前面的都完成就发生就是最早

事件的最迟发生时间：从后往前，后继节点的最迟-边的权值（找其中最小的）超过最迟后面就无法完成

源点和汇点的最早(都为0)和最晚(路径最大值)相同

20.有向图的极大强连通子图，称为强连通分量

## 习题

1.![image-20200606154540943](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606154540943.png)

答：若要让顶点最少，就是顶点之间的边尽可能的多，最好每两个点都有边，又说是非连通，那么可以一个连通图加一个点。8个顶点有(8*7)/2=28条边加一个点就是非连通，所以是9个点

2.一个有n个结点的图,最少有(1 )个连通分量,最多有(n )个连通分量

答：最少就是整体是连通图时，最多就是每个顶点都是孤立的点，那么每个点都是连通分量，注意不可能有0个连通分量，只要有点(哪怕一个)就得是连通分量

3.N个顶点的无向连通图用邻接矩阵表示时,该矩阵 至少有 2(n-1) 个非零元素。

答：邻接矩阵非零元素的个数即图的边数之和的2倍(因为无向一条边会被存两次)，图最少有n-1条边，那么矩阵最少有2(n-1)个非零元素

4.深度优先和广度优先遍历结果均不唯一

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163156758.png" alt="image-20200606163156758" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163249031.png" alt="image-20200606163249031" style="zoom:67%;" />

5.最小生成树问题

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606170558929.png" alt="image-20200606170558929"  />

若是Kruskal算法即加边，第一次选取最小的一条边即(v1,v4)第二次最小的边是8即图中所示三个边

若是Prim算法即加点法，从V4开始，v4可到达的点中到达v1最小，然后v1和v4所能到达的其他点中(v1,v3)和(v4,v3)最小，所以答案为(v2,v3)

6.下图共有3种拓扑排序P

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606201807076.png" alt="image-20200606201807076" style="zoom: 33%;" />

7.判断一个图是否有回路除了用拓扑排序还可以用深度优先遍历（若遍历转一圈回到自身即存在回路）

8.有向图可拓扑排序的判别条件是____不存在环____(拓扑排序的定义就是对有向无环图定义的)

9.邻接表示例 ，注意存的是顶点的数组下标，即使有权值也是存下标

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220207579.png" alt="image-20200606220207579" style="zoom:67%;" />

10最小生成树计算过程(加边不构成回)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220547569.png" alt="image-20200606220547569" style="zoom:50%;" />

11.最短路径问题

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220836613.png" alt="image-20200606220836613" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220910729.png" alt="image-20200606220910729" style="zoom:50%;" />

12.AOE网问题

![image-20200606223846889](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223846889.png)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223938221.png" alt="image-20200606223938221" style="zoom:80%;" />

13.由邻接矩阵写成深度优先和广度优先遍历结果

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607110925173.png" alt="image-20200607110925173" style="zoom: 80%;" />

深度优先：要求越深越好。第一行1和7有边，然后由7出发，7和3有边，然后由3出发，3和4有边.......

广度优先：要求越广越好。第一行1和7,1和9有边(所以7和9是1的左右孩子)，然后7和9同时出发......

14.由邻接表写成深度优先和广度优先遍历结果

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607111541381.png" alt="image-20200607111541381" style="zoom: 80%;" />深度优先：0出发，0后面有1，2，3。所以遍历结果为0 1 2 3

广度优先：0出发，0后面第一个为1，由1出发，1后面第一个0访问过了，所以访问2，由2出发。2后面0和1都被访问过了，所以访问3也是 0 1 2 3

注意深度优先给出邻接表不能画图求，画图比如0后面的1 2 3是没有次序的，先访问哪个都行。但是若给出邻接表那么一定先访问1，所以邻接表求深度优先遍历是唯一的

虽然这题二者结果相同，但思想不同(越深越好和越广越好)

15.用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是____逆拓扑有序___

答：比如有A->B->C。A先入栈，然后A可到B所以B入栈，B可到C所以C入栈，C没有可达的所以C出栈，然后是BA出栈。而拓扑排序先是A，删除A的出边，B入度为0所以是B，以此类推得到ABC

这题说的退栈返回打印顶点不是按照深度优先搜索的顺序输出，最先访问的在栈底最后才能弹出

# 7.查找

## 知识点

1.线性表的查找（静态查找表）

- 顺序查找   （就是最简单的按顺序一个一个比较）
- 折半查找(二分查找)     （要求是顺序存储有序表）
  - data[mid] == k    找到元素，返回下标mid
  - data[mid] > k      high=mid-1 (k比中间值小，要向中间值左边继续找)
  - data[mid] < k      low=mid+1 (k比中间值大，要向中间值右边继续找)
  - 助记：就是找到中间值比较待查元素和中间值，再换个中间值再比较
- 分块查找   块之间有序(左块最大小于右块最小)，块内任意，另建索引表放每块最大关键字

2.折半查找的判定树：把中间位置的值作为树根，左边和右边的记录作为根的左子树和右子树

判定树的中序遍历(左根右)得到的是有序的序列(判定树左子树比根节点小，右子树比根节点大)

3.加入监视哨(存待查元素)    免去每一步查找都要判断是否查找完的情况，只要读到监视哨就说明没查到

4.树表的查找（动态(可插入删除)查找表）

- 二叉排序树（判定树就是二叉排序树，左比根小右比根大）
- 平衡二叉树（AVL） 左右子树高度差绝对值不超过1
  - 平衡因子：左子树的高度减去右子树的高度只能为0、-1、+1
  - 由于后人发现树越矮查找效率越高因此发明了AVL
- B-树
- B+树

5.二叉排序树的删除：缺右补左，缺左补右，不缺左(左子树)中(中序)后(最后一个)

![image-20200612201608844](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612201608844.png)

## 习题

1.折半查找求判定树

![image-20200612154158673](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612154158673.png)答：先找中间的值，(1+20)/2=10，所以1-9为10的左子树(比根小)，11-20为10的右字树。

比较时先和10比较，若比10小，则比较1-9，那先和谁比较呢，1-9中的中间值为(1+9)/2=5，所以先和5比较(即5和10相连)。如果还比5小，那就要和1-4比了，同样1-4先和谁比呢，1-4的中间值(1+4)/2=2，所以先和2比较(即2和5相连比5小在左边)，其他依次类推

查找为4的有1、3、6、8、11、13、16、19(依次和10,15,18,19比较所以4次)

2.用顺序表和单链表表示的有序表均可使用折半查找方法来提高查找速度。 （错）

答：单链表无法使用折半查找必须是顺序存储，因为对取中间值

3.二叉排序树序列判定![image-20200612170421688](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612170421688.png)

答：二叉排序树序列可理解为一个元素与二叉排序树比较的记录构成的序列。A中91后面是24说明待查元素X比91小所以后面是24，而24后面是94，说明X比24大，但是24前面已经比较过91了(说明已经肯定比91小了)，现在后面又来了个94显然是错的