# 各类型存储结构

#### 顺序表

![image-20200529171311253](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png)

```c
#define MAXSIZE 100	//顺序表可能达到的最大长度
typedef struct
{
    ElemType *elem;	//存储空间的基地址(例如用L.elem[0]取元素)
    int length;	//当前长度
}SqList;
```

L.elem[i]取值 	//L.length-1=>i>=0，如元素为1,2,3，L.length=3，i=0,1,2

#### 单链表

![image-20200529170625502](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png)

```c
typedef struct LNode
{
    ElemType data;	//结点的数据域
    struct LNode *next;	//结点的指针域，指向下一结点
}LNode,*LinkList;	//LinkList为指向结构体LNode的指针类型(相当于LNode *)
```

若带头结点，空表条件为L->next==NULL（L为头指针有头结点就指向头结点）

若不带头结点，空表条件为L==NULL

#### 双向链表

![image-20200529170658268](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png)

```c
typedef struct DuLNode
{
    ElemType data;	//结点的数据域
    struct DuLNode *prior;	//指向直接前驱
    struct DuLNode *next;	//指向直接后继
}DuLNode,*DuLinkList;	
```

#### 顺序栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png" alt="image-20200529171934385" style="zoom: 50%;" />

```c
#define MAXSIZE 100	//顺序栈存储空间的初始分配量
typedef struct
{
    SElemType *base;	//栈底指针
    SElemType *top;		//栈顶指针
    int stacksize;		//栈可用的最大容量
}SqStack;
```

栈空：S.top==S.base	//首尾指针相同

栈满：S.top-S.base==S.stacksize	//尾-首等于最大容量即为满

#### 链栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png" alt="image-20200529171646363" style="zoom: 50%;" />

```c
//定义类似，类似操作受限的单链表
typedef struct StackNode
{
    ElemType data;	//数据域
    struct StackNode *next;	//指向下一结点
}StackNode,*LinkStack;
```

链栈一定是没有头结点，所以栈空的条件为：S==NULL

#### 循环队列

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png" alt="image-20200529172331805" style="zoom:50%;" />

```c
#define MAXSIZE 100 //队列可能达到的最大长度
typedef struct
{
    QElemType *base;	//存储空间的基地址
    int front;	//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）
    int rear;	//尾指针
}SqQueue;
```

队空：Q.front==Q.rear	//首尾指针相同

//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1

队满：(Q.rear+1)%MAXSIZE==Q.front	

#### 链队

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png" alt="image-20200529172642776" style="zoom: 60%;" />

```c
//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针
typedef struct QNode
{
    QElemType data;	//数据域
    struct QNode *next;	//指向下一结点
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;	//队头指针(相等于QNode *front)
    QueuePtr rear;	//队尾指针
}LinkQueue;
```

队空：Q.front=Q.rear

# 4.串、数组和广义表

## 求next数组和nextval数组

![image-20200530144018875](/home/zss/.config/Typora/typora-user-images/image-20200530144018875.png)

当j=1(即第一个字符)时为特殊情况next和nextval均为0

#### next数组：其值为当前字母前方的最大前后缀+1

例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1

j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2

j=5(A)，前面有ABAB，前后缀为AB，2+1=3	//ABA和BAB不等，所以AB为最大前后缀

#### nextval数组：两种情况

J对应的字母与next[j]的值转换为j对应的字母==不等==时，nextval值为next[j]

J对应的字母与next[j]的值转换为j对应的字母==相等==时，nextval值为nextval[next[j]]

> 由此可看出要想求nextval，必须正确的求出next

例如：j=2，j对应的字母为B，next[j]即next[2]=1，也就是j=1对应的字母为A，B与A不等则nextval值为next[2]=1

j=3，j对应的字母为A，next[j]即next[3]=1，也就是j=1对应的字母为A，A与A相等则nextval值为nextval[next[j]]=nextval[1]=0

## 行优先和列优先

![image-20200530152310875](/home/zss/.config/Typora/typora-user-images/image-20200530152310875.png)

其实就是行优先就是先一行一行的存，列优先就是一列一列的存

其元素位置如a\[2][3]位置不变，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它

## 广义表

广义表长度：即元素个数(最外层括号里的小括号算一个元素)

广义表深度：就看有多少对括号就行(注意要将里面的字表全部展开)

表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾

> 注意表头是第一个元素不带最外层的那个括号，表尾带最外层的括号

例如A=((a,b),c)，表头为(a,b)而表尾为(c)



串的子串个数为n(n+1)/2+1（空串也算）

## 习题

![image-20200530201544055](/home/zss/.config/Typora/typora-user-images/image-20200530201544055.png)



# 有头尾指针的有：顺序栈和队列(顺序和链式)

- 顺序栈（栈顶和栈底）
- 循环队列
- 链队