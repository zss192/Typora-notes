# 各类型存储结构

![image-20200531145418964](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200531145418964.png)

## 顺序表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png" alt="image-20200529171311253" style="zoom: 50%;" />

```c
#define MAXSIZE 100	//顺序表可能达到的最大长度
typedef struct
{
    ElemType *elem;	//存储空间的基地址(例如用L.elem[0]取元素)
    int length;	//当前长度
}SqList;
```

L.elem[i]取值 	//L.length-1=>i>=0，如元素为1,2,3，L.length=3，i=0,1,2

## 单链表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png" alt="image-20200529170658268" style="zoom: 67%;" />

```c
typedef struct LNode
{
    ElemType data;	//结点的数据域
    struct LNode *next;	//结点的指针域，指向下一结点
}LNode,*LinkList;	//LinkList为指向结构体LNode的指针类型(相当于LNode *)
```

若带头结点，空表条件为L->next==NULL（L为头指针指向头结点永不为空）

若不带头结点，空表条件为L==NULL

## 双向链表

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png" alt="image-20200529170625502" style="zoom: 67%;" />

```c
typedef struct DuLNode
{
    ElemType data;	//结点的数据域
    struct DuLNode *prior;	//指向直接前驱
    struct DuLNode *next;	//指向直接后继
}DuLNode,*DuLinkList;	
```

## 顺序栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png" alt="image-20200529172642776" style="zoom: 50%;" />

```c
#define MAXSIZE 100	//顺序栈存储空间的初始分配量
typedef struct
{
    SElemType *base;	//栈底指针
    SElemType *top;		//栈顶指针
    int stacksize;		//栈可用的最大容量
}SqStack;
```

栈空：S.top==S.base	//首尾指针相同

栈满：S.top-S.base==S.stacksize	//尾-首等于最大容量即为满

## 链栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png" alt="image-20200529171934385" style="zoom: 50%;" />

```c
//定义类似，类似操作受限的单链表
typedef struct StackNode
{
    ElemType data;	//数据域
    struct StackNode *next;	//指向下一结点
}StackNode,*LinkStack;
```

链栈一定是没有头结点，所以栈空的条件为：S==NULL

## 循环队列

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png" alt="image-20200529171646363" style="zoom: 50%;" />

```c
#define MAXSIZE 100 //队列可能达到的最大长度
typedef struct
{
    QElemType *base;	//存储空间的基地址
    int front;	//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）
    int rear;	//尾指针
}SqQueue;
```

队空：Q.front==Q.rear	//首尾指针相同

//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1

队满：(Q.rear+1)%MAXSIZE==Q.front	

## 链队

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png" alt="image-20200529172331805" style="zoom: 67%;" />

```c
//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针
typedef struct QNode
{
    QElemType data;	//数据域
    struct QNode *next;	//指向下一结点
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;	//队头指针(相等于QNode *front)
    QueuePtr rear;	//队尾指针
}LinkQueue;
```

队空：Q.front=Q.rear

由于串、数组、广义表的存储结构不是重点在这里就不再列出其存储结构

## 小结

有==头尾指针==的有：==顺序栈和队列==(顺序和链式)

- 顺序栈（栈顶和栈底）
- 循环队列
- 链队

## 顺序二叉树(不常用)

<img src="/home/zss/.config/Typora/typora-user-images/image-20200604172406949.png" alt="image-20200604172406949" style="zoom: 67%;" />

```c
#define MAXSIZE 100	//二叉树的最大结点数
typedef TElemType SqBiTree[MAXSIZE]	//0号存储根结点
SqBiTree bt;
```

## 二叉链表(常用)

<img src="/home/zss/.config/Typora/typora-user-images/image-20200604172437927.png" alt="image-20200604172437927" style="zoom: 67%;" />

```c
typedef struct BiTNode
{
	TElemType data;	//结点数据域
    struct BiTNode *lchild,*rchild;	//左右孩子指针
}BiTNode,*BiTree;
```

## 线索二叉树

<img src="/home/zss/.config/Typora/typora-user-images/image-20200604173554027.png" alt="image-20200604173554027" style="zoom:67%;" />

```c
typedef struct BiThrNode
{
    TElemType data;
    struct BiThrNode *lchild,*rchild;	//左右孩子指针
    int LTag,RTag;	//左右标志
}BiThrNode,*BiThrTree;
```

## 孩子兄弟二叉树

<img src="/home/zss/.config/Typora/typora-user-images/image-20200604174323321.png" alt="image-20200604174323321" style="zoom:67%;" />

```c
tyrpedef struct CSNode	//又称二叉链表表示，本质存的是树用类似存二叉树的方法存
{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;	//即左是孩子右是兄弟
}CSNode,*CSTree;
```





# 1.绪论

1.逻辑结构：数据之间的相互关系。

- 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。
- 线性结构 数据元素之间一对一的关系
- 树形结构 数据元素之间一对多的关系
- 图状结构或网状结构 结构中的数据元素之间存在多对多的关系

也可分为线性结构(可理解成一条直线能串起来)和非线性结构

2.存储结构分为顺序存储结构和链式存储结构

3.算法**五个特性**： 有穷性、确定性、可行性、输入、输出

4.算法设计要求：正确性、可读性、健壮性、高效性。(好的算法)

5.typedef可以理解成给现有数据类型起个别名

例如：typedef struct{.....}SqList，即给struct{......}起了个名字叫SqList

也用于类似于typedef int ElemType; 给int 起个别名叫ElemType即ElemType a;等价于int a;

这样做的好处是代码中用ElemType定义变量，如果想修改变量类型只需修改typedef ** ElemType即可，而不用一一修改。

> 我们注意到有时候会有typedef struct LNode{...}LNode，即struct后有个LNode,这是因为如果结构体内部有指向结构体的指针则必须在struct后面加上LNode(单链表里有next指针struct LNode *next)

6.时间复杂度：可以理解成就看执行了多少次

7.研究数据结构就是研究数据的逻辑结构、存储结构及其基本操作

8.抽象数据类型的三个组成部分为数据对象、数据关系、基本操作。



# 2.线性表

**1.线性表和有序表合并的时间复杂度**

线性表的合并时间复杂度为O(m*n)

A=(7,5,3,11)，B=(2,6,3)，结果为A=(7,5,3,11,2,6)

算法需要循环遍历B(O(n))且LocateElem(A)(判断是否与B重复为O(m))所以为O(m*n)

有序表的合并时间复杂度为O(m+n)

A=(3,5,8,11)，B=(2,6,8)，结果为A=(2,3,5,6,8,11)

算法只需同时遍历A和B，然后将还没遍历完的那个直接插到最后就行，所以是相加

2.顺序表插入平均移动n+1/2，删除平均移动n-1/2

# 4.串、数组和广义表

## 数组

### 求next数组和nextval数组

![image-20200530144018875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png)

当j=1(即第一个字符)时为特殊情况next和nextval均为0

### next数组：其值为当前字母前方的最大前后缀+1

例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1

j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2

j=5(A)，前面有ABAB，前后缀为AB，2+1=3	//ABA和BAB不等，所以AB为最大前后缀

### nextval数组：两种情况

J对应的字母与next[j]的值转换为j对应的字母==不等==时，nextval值为next[j]

J对应的字母与next[j]的值转换为j对应的字母==相等==时，nextval值为nextval[next[j]]

> 由此可看出要想求nextval，必须正确的求出next

例如：j=2，j对应的字母为B，next[j]即next[2]=1，也就是j=1对应的字母为A，B与A不等则nextval值为next[2]=1

j=3，j对应的字母为A，next[j]即next[3]=1，也就是j=1对应的字母为A，A与A相等则nextval值为nextval[next[j]]=nextval[1]=0

### 行优先和列优先

![image-20200530152310875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530152310875.png)

其实就是行优先就是先一行一行的存，列优先就是一列一列的存

无论是哪个其元素位置如a\[2][3]位置不变，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它

## 广义表

广义表是线性表的推广(非线性)，也称列表（暂时理解成python里的列表）

广义表元素可为原子或子表

广义表长度：即元素个数(最外层括号里的小括号算一个元素)

广义表深度：就看有多少对括号就行(注意要将里面的子表全部展开)

表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾

> 注意表头是第一个元素不带最外层的那个括号，表尾带最外层的括号

例如A=((a,b),c)，表头为(a,b)而表尾为(c)

## 串

串的子串个数为n(n+1)/2+1（空串也算所以加1）

## 习题

![image-20200530201544055](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530201544055.png)

# 5.树和二叉树

## 知识点

1.满二叉树(最完美最满的状态)   完全二叉树(最右面缺而且是最后一层缺)

完全二叉树度为1的结点个数为0或1

![image-20200604171747502](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604171747502.png)

2.二叉树常用性质

- n~0~= n~2~+1 即终端节点个数为度为2的结点个数加1
- 有 n 个结点的完全二叉树的深度为⎣log2 n⎦+1 
- 深度为k的二叉树最多有2^i-1^个结点(满二叉树)

3.二叉树遍历

- 先序遍历DLR：根节点->左子树->右子树
- 中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序
- 后续遍历LRD：左子树->右子树->根节点。需要栈的支持。
- 先后中遍历指的是根结点的位置，且时间复杂度均为O(n)（自己便于记忆写的）
- 层次遍历：一层一层从上到下，从左到右

4.二叉树线索化目的是加快查找结点的前驱或后继的速度。实质上就是遍历一次二叉树，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点

5.哈夫曼树即带权路径最短树，也称最优树。

树的带权路径长度=树根到各结点的路径(树根到该结点要走几步)乘对应权值；通常记作 WPL=∑wi×li

6.哈夫曼编码是最优前缀编码(任一个编码都不是其他编码的前缀，便于通信减少数据传输)

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604205104233.png" alt="image-20200604205104233" style="zoom: 50%;" />

哈夫曼树没有度为1的结点，且不一定是完全二叉树

7.树的存储结构有三种:双亲表示法、孩子表示法、孩子兄弟表示法,其中孩子
兄弟表示法是常用的表示法,任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。

8.含有n个节点的二叉树共有(2n)!/n!*(n+1)!	(常考3个节点共5种)

9.二叉树的高度要看节点不是看边。(根节点为第一层)

## 习题

**1.**

![image-20200604180443957](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604180443957.png)

答：n~0~= n~2~+1              ==n~1~=0或n~1~=1==        n~0~+n~1~+n~2~=1001

**2.**

![image-20200604181448145](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604181448145.png)

**3**.在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是______82_。

答：==任何树中，分支数比节点数少1==

题目中，分支数为20\*4+10\*3+1\*2+10\*1=122，所以有123个节点

度为0的节点为123-20-10-1-10=82

**4.**设哈夫曼树中有199 个结点,则该哈夫曼树中有_100__个叶子结点

答：哈弗曼树没有度为1的点,n0=n2+1,n0+n2=199,所以n0=100

**5.**一棵高度为4的完全二叉树至少有______8_个结点

答：前三层是满二叉树，最后一层只有一个即1+2+4+1=8

**6.**

![image-20200605151226555](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151226555.png)

后是左右根，所以C是根，根据中序(左根右)得到DEBA均是C左子根

根据后序的DABE得到E是DABE的根，再由中序的DEBA得到D是E的左字根，BA是E的右子根

后序是左右根是AB，而中序是左根右是BA，正好相反则当没有左时正好是右根和根右，即B是根

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151625428.png" alt="image-20200605151625428" style="zoom:50%;" />