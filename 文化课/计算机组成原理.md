# 计算机系统概论

## 知识点

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608144821042.png" alt="image-20200608144821042" style="zoom: 67%;" />

1.时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。

2.主频(时钟频率)：每秒钟含有多少个时钟周期(1.2GHz即每秒钟含有1.2x10^9个时钟周期)。

3.CPI：一条指令所需要的时钟周期个数。

4.MIPS：每秒钟能执行多少个==100万==条指令。
![](https://img-blog.csdnimg.cn/2020021912112010.png)

5.MFLOPS：每秒百万次浮点操作次数。

6.CPU执行时间：TCPU=In×CPI×TC (指令条数\*一条指令需要几个时钟周期\*时钟周期长度)

>In：执行程序中==指令==的==总数==<br>
>CPI(Clock Cycle Per Instruction)：执行每条==指令所需==的平均时钟==周期个数==<br>
>TC：时钟==周期时间==的长度

7.吞吐量：计算机某一时间间隔内能够处理的信息量(能吞多少)

8.响应时间：从事件开始到事件结束的时间,也称执行时间.

7.冯●诺依曼型计算机设计思想主要有两项:

- 将十进制改为二进制,从而太太简化了计算机的结构和运算过程;
- 存储程序的思想，将程序与数据一起存储在计算机内，使得计算机的全部运算成为真正的自动过程。

8.用嘴(一句一句最后生成目标程序)来解释，用手(一步到位最后不生成目标程序)来编译

编译程序将高级语言转换为机器代码再执行，解释程序用源程序直接解释，解释一句执行一句不用转换成机器代码。所以编译要比解释速度快

9.控制器可根据==不同的周期==(取指周期或者执行周期)来区分该地址的存储单元存储的是数据还是指令。

## 习题

1.假定机器M的时钟频率为200MHz，程序P在机器M上的执行时间为12s。对P优化，将所有乘4指令都换成了一条左移两位的指令，得到优化后的程序P'。若在M上乘法指令的CPI为102，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中的乘法指令条数为_______4x10^6^________

答：P'的执行时间为10s,比12少了2s，由时钟频率得每秒有2x10^8^个时钟周期，即少了4x10^8^个时钟周期

每条左移指令比乘法指令少了100个时钟周期，那么乘法指令个数即总共少的时钟周期/每条指令时钟周期

2.此题MIPS为400

![image-20200608152105898](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608152105898.png)

答：平均CPI=2x0.5+ 3x0.2+4x0.1+5x0.2=3，即执行一个指令平均需要3个周期

MIPS为每秒可执行的百万条指令数，1.2GHZ为1200MHZ即一秒有1.2*10^9^个周期，总周期=一个指令所需周期\*有多少指令。1200/3=400（M=10^6^,G=10^9^）

3.程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M.上的执行时间是_______16.8s____

答：CPI即执行一条指令所需的时钟周期数。假设M机器原时钟周期为x,原CPI为y, P程序的指令数为z，可得P程序执行时间为xyz= 20s。

编译优化后M机器的CPI变为1.2y, P程序的指令数变为0.7z,则P程序执行时间为1.2*0.7xyz,故其执行时间为
16.8s。

4.

# 运算方法和运算器

## 知识点

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609143207561.png" alt="image-20200609143207561" style="zoom: 80%;" />1.数字0在原码反码补码的表示

[+0]原码=0000 0000，  [-0]原码=1000 0000

[+0]反码=0000 0000，  [-0]反码=1111 1111

[+0]补码=0000 0000，  [-0]补码=0000 0000   （补码中是唯一的）

0的移码也是唯一的1000 0000

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609151740827.png" alt="image-20200609151740827" style="zoom:67%;" />

由于补码0是唯一的所以补码范围要多一个负数

2.对于规格化的浮点数，尾数有三种形式：（小数点左边的是符号位）

- 0.1xx……x(原码、补码、反码都是正数的形式)
- 1.0XX……X(补码、反码是负数的形式)
- 1.1xx……X(原码是负数的形式)尾数用原码表示，B是不符合规格化的形式

3.余3码就是8421码加3所得

4.奇偶校验码：加上校验码后1的个数为奇数就是奇校验。不具备纠错能力。

5.海明码：设有k个数据位，则应设r个校验位，r满足2^r^-1 ≥ k + r 。具有一位纠错能力。

6.循环冗余检验码(CRC)：k位校验位拼接在n位数据位后面，即为n+k，如何生成检验码见下面习题

7.A的ascii码：65            a的ascii码：97

8.已知[x]补，求[-x]补：将[x]补连同符号位求反+1

9.移码就是补码的符号位求反

> 由于负数的补码如-21(101011)看着好像大于21(010101)，实际正好是21更大，所以浮点数的阶码用移码表示能直观的看出大小便于加减运算

10.-1的补码永远是全1(可理解为全1加1等于全0)

11.由于补码溢出无法看出是上溢(大于最大数)还是下溢，因此引入变形补码

- 两个符号位不同时表溢出(01为正溢出)
- 最高位那个数代表真正的符号位
- 两个符号位均参与运算，若进位舍去

12.==补码乘除之后再写，这里先跳过(主要是太多了)！！！！！！！！！！==

13.IEEE754计算公式：真值x=(-1)^S^*1.M*2^e^（S为符号位(正还是负)，E为阶码(转换成e代表多少次方)，M为尾数(小数点后面的数)，顺序为SEM）其中e=E-127(可记成大E大所以要减)



## 习题

1.写出D=101101的海明码

答：:one:首先确定检验位的个数：k=6，2^r^-1 ≥ k + r即2^r^ ≥7+r，所以r=4

:two:确定检验码的位置：检验码P~i~(i=1,2...)的位置为2^i-1^

注意从M10到M1，从大到小且没有0

![image-20200609150117418](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609150117418.png)

:three:求出检验码的值：校验位Pi的值即为所有需要Pi校验的数据位求异或。

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609150430484.png" alt="image-20200609150430484" style="zoom:80%;" />

如P2对应M2，需要它的有D1即M3(2+1)、D3即M6(2+4)、D4即M7(2+4+1)......

所以最后的海明码为1011100100

2.已知x=11011，y=-10101，用变形补码计算x+y

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609154616627.png" alt="image-20200609154616627" style="zoom:70%;" />

> 注意一定要先转换成补码再添符号位运算

3.假设M(x)=x^3^+1(发送信息的多项式)，G(x)=x^3^+x+1(生成多项式，代表校验位信息)。

:one: 那么M(x)代表的二进制码为: 1001(1*x^3^+1\*x^0^)，G(x)代表的二进制码为: 1011

:two:将M(x)的多项式左移G(x)的最高次数，变为1001 000

:three:将1001000对1011做模2除法得到余数为110,将其与被除数1001合并得到CRC码1001110

> 这里要注意第三步的模2除法和普通除法不同，模2除法不会向上一位借位也不比较被除数和除数的大小，如图中第三位商数(1101>1000但仍可做减操作)<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609195155116.png" alt="image-20200609195155116" style="zoom:80%;" />

4.若浮点数x的754标准存储格式为(41360000)~16~ ,求其浮点数的十进制数值。

![image-20200609225853843](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609225853843.png)

5.将数(20. 59375)1o转换成754标准的32位浮点数的二进制存储格式。

![image-20200609230432591](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609230432591.png)

# 多层次的存储器

## 知识点

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610135354300.png" alt="image-20200610135354300" style="zoom:80%;" />

1.存储器按存取方式可分为

- 随机存取存储器（RAM）可读可写，断电即失(也称易失性)
  - 静态RAM(SRAM)   常用做高速缓冲存储器
  - 动态RAM(DRAM)  常用做主存
- 只读存储器（ROM）只读不写，断电保留(也称非易失性)
- 顺序存取存储器（如磁带）属于串行访问存储器
- 直接存取存储器（如磁盘）属于串行访问存储器

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140643769.png" alt="image-20200610140643769" style="zoom:80%;" />

2.这些存储器名称中带E的都表示可擦除（可能出选择题）

3.为了解决存储器大容量、低价格、高速度三者之间的矛盾关系，常采用多级存储器结构

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140844977.png" alt="image-20200610140844977" style="zoom:67%;" />

缓存-主存层次主要解决CPU和主存速度不匹配的问题，数据交换由硬件完成。

主存辅存层次主要解决存储系统的容量问题，数据交换由硬件和操作系统共同完成

4.存储器带宽就是每秒存储器存储的信息量

5.SRAM存取速度快但容量不如DRAM（记住SRAM用作高速缓冲存储器，速度肯定快）

6.DRAM采用电容存储，由于电荷量会减少所以必须定期(若不说明则是2ms)刷新,可分为

- 集中刷新（集中到一段时间，集中歼灭）死时间是刷新总时间
- 分散刷新（分散到每个存取周期进行，分散歼灭）加倍存取周期死时间为0
- 异步刷新（折中方案，有计划的刷新）死时间就是一个读写周期(刷新周期/行数)

> 刷新的实质就是读出数据再写入（对行刷新，若不说明刷新一行等于一个存储周期）

7.ROM也是随机存取(像数组下标一样访问)，但随机存取**存储器**要求可读可写，ROM只读，所以把ROM和RAM分开（第一个随机存取只是取信息的方式和存储器的随机存取不一样）

8.如果要求将容量为axb的芯片组成容量为cxd的芯片，假设需要芯片的数量为n,则n=(cxd)/axb     （a是字线连接地址线，b是位线连接数据线）

9.命中率：CPU要访问的信息在Cache中的比例（cache存取次数/(cache存取+主存存取)）

10.平均访问时间：t~a~=命中率×访问cache的时间+(1-命中率)×访问主存时间 (t~a~=ht~c~+(1-h)t~m~)

11.访问效率：访问cache时间/平均访问时间 (e=t~c~/t~a~)

12.CPU与Cache之间传送数据的基本单位是字，而主存与Cache之间传送数据的基本单位是块(一块包括多个字)。（可理解为CPU容量少传输的也少，主存容量大传输的也大）

13.为了把主存的部分内容放到Cache中要把主存地址转换为Cache地址（因为主存和Cache用块传输，所以主要是块号的转换）

- 直接映射     根据行号指定特定行比（适合大容量Cache）
- 全相联映射  与Cache所有行都比（适合小容量Cache）
- 组相联映射   先根据组号找到对应组，再在组中一个一个比(折中的方法)

![image-20200610171302861](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610171302861.png)

> 可以看到直接映射因为要找特定行，所以多了行号地址，组相联因为要找特定组所以多了组号地址，而全相联因为是一行一行比所以啥也没有

14.替换策略：当要放新的东西而Cache满时就要替换

- 最不经常使用(LFU)算法     首先淘汰一定时期内被访问次数最少的
- 近期最少使用(LRU)算法     首先淘汰最长时间未被使用的
- 随机替换

15.Cache要和主存内容保持一致，CPU对Cache的写入更改了它，所以要用到写操作策略

- 写回法    只修改Cache的内容而不立即写入主存，此行被换出时写入主存
- 全写法    Cache和主存同时修改
- 写一次法  处理和写回法一致，只是第一次命中要同时写入主存（折中处理）

16.TLB(快表)、页表和Cache之间的命中关系

记住只要TLB(页表分为快表和慢表)和Cache有一个命中，页表一定命中，但页表命中那俩不一定命中(数据在主存不在Cache时)，也可能都不命中

17.DRAM采用地址复用技术，地址线为正常的一半，例如你计算的用10根地址线实际用5根就行   （传两次地址的策略）

## 习题

1.RAM和ROM的区别

![image-20200610145652114](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610145652114.png)

答：RAM断电会失去信息而ROM不会，二者访问信息的方式都是随机存取。Cache需要可读可写，而ROm只能读不能写，肯定不适合。DRAM(动态RAM)才需要刷新。

2.Flash存储器

![image-20200610150200185](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610150200185.png)

3.假定用若干个2K×4位芯片组成一个8K×8位存储器，则地址0B1FH所在芯片的最小地址是

答：8k\*8/2k*4=8，需要8个芯片，8k=2^13^，所以需要13位地址，其中包含3位片选地址(决定选中哪个芯片)。2个4位的芯片构成一个8位的(存取数据一次最少8位)，所以需要4组

:one: 每组芯片是2k*8即11个地址线，4组需要2位片选信号，所以每组后11位是从全0到全1

第1组芯片地址范围：000==0 0==000 0000 0000 ~ 0000 0111 1111 1111（黄色的为片选信号）

第2组芯片地址范围：000==0 1==000 0000 0000 ~ 0000 1111 1111 1111

第3组芯片地址范围：000==1 0==000 0000 0000 ~ 0001 0111 1111 1111

第4组芯片地址范围：000==1 1==000 0000 0000 ~ 0001 1111 1111 1111

0B1FH的地址格式是0000 1011 0001 1111，可知是第二组中的一个地址，这个地址所在芯片最小的为地址为0000 1000 0000 0000，即0800H

:two:0B1F的高三位为010(注意是低13的高3位)，所以是第二片芯片，那起始地址肯定是高3位是010后面10位全是0，即0800H

4.某计算机存储器按字节编址，主存地址空间大小为64MB，现用4MB×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（26位）。

答：MAR要能寻址整个存储器，虽然题目说组成32MB的主存，但是剩余的32MB以后也会用，所以也要考虑，64MB=2^26^，所以最少26位

5.假设 Cache完成缓存的次数为 2000次，主存完成存取的次数为50次。已知Cache的存储周期为50ns，主存的存储周期为200ns，试求:命中率、平均访问时间、效率。

答：:one:命中率为  2000/(2000+50)=97%

:two:t~a~=ht~c~+(1-h)t~m~=0.97\*50ns+(1-0.97)\*200ns=54.5ns（a表average,c表cache,m表main）

:three:效率e=t~c~/t~a~=50/54.5=91.7%

6.一个组相联cache由64个行组成，每组4行。主存储器包含4K个块，每块128字。请表示内存地址的格式。

答：128字=2^7^，所以字地址位数为7

Cache共64行，每组4行，所以需要16组，16=2^4^，即只需4位组号地址即可表示16组

:one: 主存有4k个块，每块128字，所以总共4k*128=2^19^，19-4-7=8即8位标记位

:two: 主存有4K个块，4k=2^12^，12-4=8，所以标记位需要8位（除去字号剩下的就是块号）

主存有4K个块，4k=2^12^，12-4=8，所以标记位需要8位

![image-20200610172722721](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610172722721.png)

> 注意这些地址是存放在主存的，所以总位数和主存的容量保持一致

7.某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是 _____________19___

答：注意是DRAM采用地址复用，4M=2^22^，地址复用所以11根就行，11+8=19

> 注意地址线是2^n^，而数据线是一个线对应一位

8.下列各类存储器中,不采用随机存取方式的是( B)
A.EPROM               B.CD-ROM           C.DRAM            D.SRAM

答：CDROM即光盘，采用串行存取方式，它是只读型光盘存储器，不属于只读存储器ROM

# 外存与IO设备

## 知识点

1.磁道：就是磁盘的一个同心圆，每个磁道又分为多个扇区(和披萨一样一块一块)

2.**道**密度：单位长度有多少个磁**道**数(同心圆)           多少道

3.**位**密度：单位**磁道**长度能记录的二进制的**位**数      多少位

4.磁盘容量：面数×每面磁道数×每条磁道的二进制位数

5.磁盘平均存取时间：T~a~=寻道(找那一圈)+延迟(找圈中哪个扇区)+传输(读写扇区时间)

6.数据传输速率：磁盘单位时间向主机传送的字节数（字节/秒）

- D~r~=rN      r为转速即每秒转多少圈(磁道)，N为每个磁道的容量
- D~r~=D*v   D为位密度即单位磁道的位数，v为线速度即每秒能沿着圈走多长

7.一个磁盘片有两个面，一个磁盘组有很多片(n)，但最上面和最下面的面不能用(即2n-2可用)

## 习题

1.磁盘组有6片磁盘， 每片有两个记录面，最上最下两个面不用。存储区域内径22cm,外径33cm,道密度为40道/cm，内层位密度400位/cm，转速6000转/分。问:

(1) 共有多少柱面?
(2)盘组总存储容量是多少?
(3)数据传输率多少?
(4)采用定长数据块记录格式，直接寻址的最小单位是什么?寻址命令中如何表示磁盘地址?
(5) 如果某文件长度超过一一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上?

答：(1)：有效存储区域为16.5-11=5.5(cm)，道密度为40道/cm，所以共40*5.5=220道即220个圆柱面（道是一圈一圈的，柱面就是一圈一圈那种）

> 要用半径而不是直径因为总圈数用半径算即可，另一半和这一半用的是同一个圈

(2)：内层磁道周长为2πR=2X3.14X11= 69.08(cm)     因为给的是内径密度所以算内径周长
每道信息量=400位/cmX 69.08cm=27632 位= 3454B    即一圈信息量  位密度×圈长度
每面信息量= 3454BX 220= 759880B     一面一共220圈     道信息×道数
盘组总容量= 759880BX10=7 598 800B    6片可用的面为10  面信息×面数

(3)：磁盘数据传输率D~r~= rN                 N为每条磁道容量，N=3454B
r为磁盘转速，r=6000转/60秒=100转/秒   （注意换算单位!!!）
D,=rN= 100X 3454B= = 345400B/s         每条磁道容量×磁道数量

(4)：最小单位是一个记录块（一个扇区）

此地址格式表示有4台磁盘，每台有16个记录面，每面有256个磁道，每道有16个扇区

![image-20200610184101789](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610184101789.png)

(5)：如果某文件长度超过-一个磁道的容量，应将它记录在同一个柱面上，因为不需要重新找道，数据读/写速度快。

